<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>HTTP ExceptionsÂ // Werkzeug Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="style.css">
  <link rel="stylesheet" type="text/css" href="pygments.css">
  <link rel="stylesheet" type="text/css" media="print" href="print.css">
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <div class="page">
    <div class="header">
      <h1><a href="index.html"><span>Werkzeug</span></a></h1>
      <p><span>The Swiss Army Knife For Python Web Developers</span></p>
    </div>
    <div class="body">
      <h2>HTTP Exceptions</h2>
      
      <div class="toc">
        <h4>Table of Contents</h4>
        <ul><li><a class="reference" href="#error-classes" id="id1" name="id1">Error Classes</a></li>
<li><a class="reference" href="#baseclass" id="id2" name="id2">Baseclass</a></li>
<li><a class="reference" href="#special-http-exceptions" id="id3" name="id3">Special HTTP Exceptions</a></li>
<li><a class="reference" href="#simple-aborting" id="id4" name="id4">Simple Aborting</a></li>
<li><a class="reference" href="#custom-errors" id="id5" name="id5">Custom Errors</a></li>
</ul>
      </div>
      
      <p>This module implements a number of Python exceptions you can raise from
within your views to trigger a standard non 200 response.</p>
<div class="section">
<h3 id="usage-example">Usage Example</h3>
<div class="syntax"><pre><span class="k">from</span> <span class="nn">werkzeug</span> <span class="k">import</span> <span class="n">BaseRequest</span><span class="p">,</span> <span class="n">responder</span>
<span class="k">from</span> <span class="nn">werkzeug.exceptions</span> <span class="k">import</span> <span class="n">HTTPException</span><span class="p">,</span> <span class="n">NotFound</span>

<span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="k">raise</span> <span class="n">NotFound</span><span class="p">()</span>

<span class="nd">@responder</span>
<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">request</span> <span class="o">=</span> <span class="n">BaseRequest</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">view</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">HTTPException</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>
</pre></div>
<p>As you can see from this example those exceptions are callable WSGI
applications.  Because of Python 2.3 / 2.4 compatibility those do not
extend from the response objects but only from the python exception
class.</p>
<p>As a matter of fact they are not Werkzeug response objects.  However you
can get a response object by calling <tt class="docutils literal"><span class="pre">get_response()</span></tt> on a HTTP
exception.</p>
<p>Keep in mind that you have to pass an environment to <tt class="docutils literal"><span class="pre">get_response()</span></tt>
because some errors fetch additional information from the WSGI
environment.</p>
<p>If you want to hook in a different exception page to say, an 404 status
code, you can add a second except for a specific subclass of an error:</p>
<div class="syntax"><pre><span class="nd">@responder</span>
<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">request</span> <span class="o">=</span> <span class="n">BaseRequest</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">view</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">NotFound</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">not_found</span><span class="p">(</span><span class="n">request</span><span class="p">)</span>
    <span class="k">except</span> <span class="n">HTTPException</span><span class="p">,</span> <span class="n">e</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">e</span>
</pre></div>
</div>
<p>All the exceptions must be imported from the <cite>werkzeug.exceptions</cite> module
unless you are using the <cite>abort</cite> callable which is available in <cite>werkzeug</cite>
too.</p>
<div class="section">
<h3 id="error-classes">Error Classes</h3>
<p>The following error classes exist in Werkzeug:</p>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.BadRequest">BadRequest</cite></dt>
<dd><p class="first"><em>400</em> <cite>Bad Request</cite></p>
<p class="last">Raise if the browser send something to the application the application
or server cannot handle.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.Unauthorized">Unauthorized</cite></dt>
<dd><p class="first"><em>401</em> <cite>Unauthorized</cite></p>
<p class="last">Raise if the user is not authorized.  Also used if you want to use HTTP
basic auth.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.Forbidden">Forbidden</cite></dt>
<dd><p class="first"><em>403</em> <cite>Forbidden</cite></p>
<p class="last">Raise if the user doesn&#8217;t have the permission for the requested resource
but was authenticated.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.NotFound">NotFound</cite></dt>
<dd><p class="first"><em>404</em> <cite>Not Found</cite></p>
<p class="last">Raise if a resource does not exist and never existed.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.MethodNotAllowed">MethodNotAllowed</cite></dt>
<dd><p class="first"><em>405</em> <cite>Method Not Allowed</cite></p>
<p>Raise if the server used a method the resource does not handle.  For
example <cite>POST</cite> if the resource is view only.  Especially useful for REST.</p>
<p class="last">The first argument for this exception should be a list of allowed methods.
Strictly speaking the response would be invalid if you don&#8217;t provide valid
methods in the header which you can do with that list.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.NotAcceptable">NotAcceptable</cite></dt>
<dd><p class="first"><em>406</em> <cite>Not Acceptable</cite></p>
<p class="last">Raise if the server cant return any content conforming to the
<cite>Accept</cite> headers of the client.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.RequestTimeout">RequestTimeout</cite></dt>
<dd><p class="first"><em>408</em> <cite>Request Timeout</cite></p>
<p class="last">Raise to signalize a timeout.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.Gone">Gone</cite></dt>
<dd><p class="first"><em>410</em> <cite>Gone</cite></p>
<p class="last">Raise if a resource existed previously and went away without new location.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.LengthRequired">LengthRequired</cite></dt>
<dd><p class="first"><em>411</em> <cite>Length Required</cite></p>
<p class="last">Raise if the browser submitted data but no <tt class="docutils literal"><span class="pre">Content-Length</span></tt> header which
is required for the kind of processing the server does.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.PreconditionFailed">PreconditionFailed</cite></dt>
<dd><p class="first"><em>412</em> <cite>Precondition Failed</cite></p>
<p class="last">Status code used in combination with <tt class="docutils literal"><span class="pre">If-Match</span></tt>, <tt class="docutils literal"><span class="pre">If-None-Match</span></tt>, or
<tt class="docutils literal"><span class="pre">If-Unmodified-Since</span></tt>.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.RequestEntityTooLarge">RequestEntityTooLarge</cite></dt>
<dd><p class="first"><em>413</em> <cite>Request Entity Too Large</cite></p>
<p class="last">The status code one should return if the data submitted exceeded a given
limit.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.RequestURITooLarge">RequestURITooLarge</cite></dt>
<dd><p class="first"><em>414</em> <cite>Request URI Too Large</cite></p>
<p class="last">Like <em>413</em> but for too long URLs.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.UnsupportedMediaType">UnsupportedMediaType</cite></dt>
<dd><p class="first"><em>415</em> <cite>Unsupported Media Type</cite></p>
<p class="last">The status code returned if the server is unable to handle the media type
the client transmitted.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.InternalServerError">InternalServerError</cite></dt>
<dd><p class="first"><em>500</em> <cite>Internal Server Error</cite></p>
<p class="last">Raise if an internal server error occoured.  This is a good fallback if an
unknown error occoured in the dispatcher.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.NotImplemented">NotImplemented</cite></dt>
<dd><p class="first"><em>501</em> <cite>Not Implemented</cite></p>
<p class="last">Raise if the application does not support the action requested by the
browser.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.BadGateway">BadGateway</cite></dt>
<dd><p class="first"><em>502</em> <cite>Bad Gateway</cite></p>
<p class="last">If you do proxing in your application you should return this status code
if you received an invalid response from the upstream server it accessed
in attempting to fulfill the request.</p>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.ServiceUnavailable">ServiceUnavailable</cite></dt>
<dd><p class="first"><em>503</em> <cite>Service Unavailable</cite></p>
<p class="last">Status code you should return if a service is temporarily unavailable.</p>
</dd>
</dl>
</div>
<div class="section">
<h3 id="baseclass">Baseclass</h3>
<p>All the exceptions implement this common interface:</p>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.HTTPException">HTTPException</cite></dt>
<dd><p class="first">Baseclass for all HTTP exceptions.  This exception can be called as WSGI
application to render a default error page or you can catch the subclasses
of it independently and render nicer error messages.</p>
<dl>
<dt><cite id="werkzeug.exceptions.HTTPException.get_response">get_response</cite> <tt class="func-signature docutils literal"><span class="pre">(environ)</span></tt></dt>
<dd>Get a response object.</dd>
</dl>
<dl class="last">
<dt><cite id="werkzeug.exceptions.HTTPException.__call__">__call__</cite> <tt class="func-signature docutils literal"><span class="pre">(environ,</span> <span class="pre">start_response)</span></tt></dt>
<dd>Call the exception as WSGI application.</dd>
</dl>
</dd>
</dl>
</div>
<div class="section">
<h3 id="special-http-exceptions">Special HTTP Exceptions</h3>
<p>Starting with Werkzeug 0.3 some of the builtin classes raise exceptions that
look like regular python exceptions (eg <cite>KeyError</cite>) but are <cite>BadRequest</cite>
HTTP exceptions at the same time.  This decision was made to simplify a
common pattern where you want to abort if the client tampered with the
submitted form data in a way that the application can&#8217;t recover properly and
should abort with <tt class="docutils literal"><span class="pre">400</span> <span class="pre">BAD</span> <span class="pre">REQUEST</span></tt>.</p>
<p>Assuming the application catches all HTTP exceptions and reacts to them
properly a view function could do the following savely and doesn&#8217;t have to
check if the keys exist:</p>
<div class="syntax"><pre><span class="k">def</span> <span class="nf">new_post</span><span class="p">(</span><span class="n">request</span><span class="p">):</span>
    <span class="n">post</span> <span class="o">=</span> <span class="n">Post</span><span class="p">(</span><span class="n">title</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;title&#39;</span><span class="p">],</span> <span class="n">body</span><span class="o">=</span><span class="n">request</span><span class="o">.</span><span class="n">form</span><span class="p">[</span><span class="s">&#39;body&#39;</span><span class="p">])</span>
    <span class="n">post</span><span class="o">.</span><span class="n">save</span><span class="p">()</span>
    <span class="k">return</span> <span class="n">redirect</span><span class="p">(</span><span class="n">post</span><span class="o">.</span><span class="n">url</span><span class="p">)</span>
</pre></div>
<p>If <cite>title</cite> or <cite>body</cite> are missing in the form a <cite>MultiDict.KeyError</cite> will be
raised which behaves like a <cite>KeyError</cite> but also a <cite>BadRequest</cite> exception.</p>
</div>
<div class="section">
<h3 id="simple-aborting">Simple Aborting</h3>
<p>Sometimes it&#8217;s convenient to just raise an exception by the error code,
without importing the exception and looking up the name etc.  For this
purpose there is the <cite>abort</cite> function.</p>
<p>It can be passed a WSGI application or a status code.  If a status code
is given it&#8217;s looked up in the list of exceptions from above and will
raise that exception, if passed a WSGI application it will wrap it in
a proxy WSGI exception and raise that:</p>
<div class="syntax"><pre><span class="n">abort</span><span class="p">(</span><span class="mf">404</span><span class="p">)</span>
<span class="n">abort</span><span class="p">(</span><span class="n">Response</span><span class="p">(</span><span class="s">&#39;Hello World&#39;</span><span class="p">))</span>
</pre></div>
<p>If you want to use this functionality with custom excetions you can
create an instance of the aborter class:</p>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.exceptions.Aborter">Aborter</cite></dt>
<dd><p class="first">When passed a dict of code -&gt; exception items it can be used as
callable that raises exceptions.  If the first argument to the
callable is a integer it will be looked up in the mapping, if it&#8217;s
a WSGI application it will be raised in a proxy exception.</p>
<p class="last">The rest of the arguments are forwarded to the exception constructor.</p>
</dd>
</dl>
</div>
<div class="section">
<h3 id="custom-errors">Custom Errors</h3>
<p>As you can see from the list above not all status codes are available as
errors.  Especially redirects and ather non 200 status codes that
represent do not represent errors are missing.  For redirects you can use
the <cite>redirect</cite> function from the utilities.</p>
<p>If you want to add an error yourself you can subclass <cite>HTTPException</cite>:</p>
<div class="syntax"><pre><span class="k">from</span> <span class="nn">werkzeug.exceptions</span> <span class="k">import</span> <span class="n">HTTPException</span>

<span class="k">class</span> <span class="nc">PaymentRequred</span><span class="p">(</span><span class="n">HTTPException</span><span class="p">):</span>
    <span class="n">code</span> <span class="o">=</span> <span class="mf">402</span>
    <span class="n">description</span> <span class="o">=</span> <span class="s">&#39;&lt;p&gt;Payment required.&lt;/p&gt;&#39;</span>
</pre></div>
<p>This is the minimal code you need for your own exception.  If you want to
add more logic to the errors you can override the <cite>get_description()</cite>,
<cite>get_body()</cite>, <cite>get_headers()</cite> and <cite>get_response()</cite> methods.  In any case
you should have a look at the sourcecode of the exceptions module.</p>
<p>You can override the default description in the constructor with the
<cite>description</cite> parameter (it&#8217;s the first argument for all exceptions
except of the <cite>MethodNotAllowed</cite> which accepts a list of allowed methods
as first argument):</p>
<div class="syntax"><pre><span class="k">raise</span> <span class="n">BadRequest</span><span class="p">(</span><span class="s">&#39;Request failed because X was not present&#39;</span><span class="p">)</span>
</pre></div>
</div>

      <div style="clear:both"></div>
    </div>
    <div class="footer">
      Werkzeug is a <a href="http://pocoo.org/">Pocoo</a> project licensed under the
      BSD license.
    </div>
  </div>
</body>
</html>