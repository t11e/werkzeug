<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Serving WSGI ApplicationsÂ // Werkzeug Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="style.css">
  <link rel="stylesheet" type="text/css" href="pygments.css">
  <link rel="stylesheet" type="text/css" media="print" href="print.css">
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <div class="page">
    <div class="header">
      <h1><a href="index.html"><span>Werkzeug</span></a></h1>
      <p><span>The Swiss Army Knife For Python Web Developers</span></p>
    </div>
    <div class="body">
      <h2>Serving WSGI Applications</h2>
      
      <p>There are many ways to serve a WSGI application.  While you&#8217;re developing it,
you usually don&#8217;t want to have a full-blown webserver like Apache up and
running, but instead a simple standalone one.  With Python 2.5 and onwards,
there is the <a class="reference" href="http://cheeseshop.python.org/pypi/wsgiref">wsgiref</a> server in the standard library.  If you&#8217;re using older
versions of Python you can download the package from the <a class="reference" href="http://pypi.python.org/">Cheeseshop</a>.</p>
<p>However, there are some caveats.  Sourcecode won&#8217;t reload itself when changed,
and each time you kill the server using <tt class="docutils literal"><span class="pre">^C</span></tt> you get a <cite>KeyboardInterrupt</cite>
error.  While the latter is easy to solve, the first one can be a pain in the
ass in some situations.</p>
<p>Because of that Werkzeug ships a small wrapper over <cite>wsgiref</cite> that spawns the
WSGI application in a subprocess and automatically reloads the application if
a module was changed.</p>
<p>The easiest way is creating a small <tt class="docutils literal"><span class="pre">start-myproject.py</span></tt> file that runs the
application:</p>
<div class="syntax"><pre><span class="c">#!/usr/bin/env python</span>
<span class="c"># -*- coding: utf-8 -*-</span>

<span class="kn">from</span> <span class="nn">werkzeug</span> <span class="kn">import</span> <span class="n">run_simple</span>
<span class="kn">from</span> <span class="nn">myproject</span> <span class="kn">import</span> <span class="n">make_app</span>

<span class="n">app</span> <span class="o">=</span> <span class="n">make_app</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="n">run_simple</span><span class="p">(</span><span class="s">&#39;localhost&#39;</span><span class="p">,</span> <span class="mf">8080</span><span class="p">,</span> <span class="n">app</span><span class="p">,</span> <span class="n">use_reloader</span><span class="o">=</span><span class="bp">True</span><span class="p">)</span>
</pre></div>
<p>You can also pass it the <cite>extra_files</cite> keyword argument with a list of
additional files (like configuration files) you want to observe.</p>
<dl>
<dt><cite id="werkzeug.serving.run_simple">run_simple</cite> <tt class="func-signature docutils literal"><span class="pre">(hostname,</span> <span class="pre">port,</span> <span class="pre">application,</span> <span class="pre">use_reloader=False,</span> <span class="pre">use_debugger=False,</span> <span class="pre">use_evalex=True,</span> <span class="pre">extra_files=None,</span> <span class="pre">reloader_interval=1,</span> <span class="pre">threaded=False,</span> <span class="pre">processes=1,</span> <span class="pre">request_handler=None)</span></tt></dt>
<dd><p class="first">Start an application using wsgiref and with an optional reloader.  This
wraps <cite>wsgiref</cite> to fix the wrong default reporting of the multithreaded
WSGI variable and adds optional multithreading and fork support.</p>
<dl class="last">
<dt>Parameters</dt>
<dd><p class="first"><strong>hostname</strong>: The host for the application.  eg: <tt class="docutils literal"><span class="pre">'localhost'</span></tt></p>
<p><strong>port</strong>: The port for the server.  eg: <tt class="docutils literal"><span class="pre">8080</span></tt></p>
<p><strong>application</strong>: the WSGI application to execute</p>
<p><strong>use_reloader</strong>: should the server automatically restart the python
process if modules were changed?</p>
<p><strong>use_debugger</strong>: should the werkzeug debugging system be used?</p>
<p><strong>use_evalex</strong>: should the exception evaluation feature be enabled?</p>
<p><strong>extra_files</strong>: a list of files the reloader should listen for
additionally to the modules.  For example configuration
files.</p>
<p><strong>reloader_interval</strong>: the interval for the reloader in seconds.</p>
<p><strong>threaded</strong>: should the process handle each request in a separate
thread?</p>
<p><strong>processes</strong>: number of processes to spawn.</p>
<p class="last"><strong>request_handler</strong>: optional parameter that can be used to replace
the default wsgiref request handler.  Have a look
at the <cite>werkzeug.serving</cite> sourcecode for more
details.</p>
</dd>
</dl>
</dd>
</dl>

      <div style="clear:both"></div>
    </div>
    <div class="footer">
      Werkzeug is a <a href="http://pocoo.org/">Pocoo</a> project licensed under the
      BSD license.
    </div>
  </div>
</body>
</html>