<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head>
  <title>Context LocalsÂ // Werkzeug Documentation</title>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <link rel="stylesheet" type="text/css" href="style.css">
  <link rel="stylesheet" type="text/css" href="pygments.css">
  <link rel="stylesheet" type="text/css" media="print" href="print.css">
  <link rel="shortcut icon" type="image/x-icon" href="favicon.ico">
</head>
<body>
  <div class="page">
    <div class="header">
      <h1><a href="index.html"><span>Werkzeug</span></a></h1>
      <p><span>The Swiss Army Knife For Python Web Developers</span></p>
    </div>
    <div class="body">
      <h2>Context Locals</h2>
      
      <div class="toc">
        <h4>Table of Contents</h4>
        <ul><li><a class="reference" href="#nutshell" id="id1" name="id1">Nutshell</a></li>
<li><a class="reference" href="#objects" id="id2" name="id2">Objects</a></li>
</ul>
      </div>
      
      <p>Sooner or later you have some things you want to have in every single view
or helper function or whatever.  In PHP the way to go are global
variables.  However that is not possible in WSGI applications without a
major drawback:  As soon as you operate on the global namespace your
application is not thread safe any longer.</p>
<p>The python standard library comes with a utility called &#8220;thread locals&#8221;.
A thread local is a global object where you can put stuff on and get back
later in a thread safe way.  That means whenever you set or get an object
to / from a thread local object the thread local object checks in which
thread you are and delivers the correct value.</p>
<p>This however has a few disadvantages.  For example beside threads there
are other ways to handle concurrency in Python.  A very popular approach
are greenlets.  Also, whether every request gets its own thread is not
guaranteed in WSGI.  It could be that a request is reusing a thread from
before and data is left in the thread local object.</p>
<div class="section">
<h3 id="nutshell">Nutshell</h3>
<p>Here a simple example how you can use werkzeug.local:</p>
<div class="syntax"><pre><span class="k">from</span> <span class="nn">werkzeug</span> <span class="k">import</span> <span class="n">Local</span><span class="p">,</span> <span class="n">LocalManager</span>

<span class="n">local</span> <span class="o">=</span> <span class="n">Local</span><span class="p">()</span>
<span class="n">local_manager</span> <span class="o">=</span> <span class="n">LocalManager</span><span class="p">([</span><span class="n">local</span><span class="p">])</span>

<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="n">local</span><span class="o">.</span><span class="n">request</span> <span class="o">=</span> <span class="n">request</span> <span class="o">=</span> <span class="n">Request</span><span class="p">(</span><span class="n">environ</span><span class="p">)</span>
    <span class="o">...</span>

<span class="n">application</span> <span class="o">=</span> <span class="n">local_manager</span><span class="o">.</span><span class="n">make_middleware</span><span class="p">(</span><span class="n">application</span><span class="p">)</span>
</pre></div>
<p>Now what this code does is binding request to <cite>local.request</cite>.  Every
other piece of code executed after this assignment in the same context can
safely access local.request and will get the same request object.  The
<cite>make_middleware</cite> method on the local manager ensures that everything is
cleaned up after the request.</p>
<p>The same context means the same greenlet (if you&#8217;re using greenlets) in
the same thread and same process.</p>
<p>If a request object is not yet set on the local object and you try to
access it you will get an <cite>AttributeError</cite>.  You can use <cite>getattr</cite> to avoid
that:</p>
<div class="syntax"><pre><span class="k">def</span> <span class="nf">get_request</span><span class="p">():</span>
    <span class="k">return</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="s">&#39;request&#39;</span><span class="p">,</span> <span class="bp">None</span><span class="p">)</span>
</pre></div>
<p>This will try to get the request or return <cite>None</cite> if the request is not
(yet?) available.</p>
<p>Note that local objects cannot manage themselves, for that you need a local
manager.  You can pass a local manager multiple locals or add additionals
later by appending them to <cite>manager.locals</cite> and everytime the manager
cleans up it will clean up all the data left in the locals for this
context.</p>
</div>
<div class="section">
<h3 id="objects">Objects</h3>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.local.LocalManager">LocalManager</cite></dt>
<dd><p class="first">Local objects cannot manage themselves. For that you need a local manager.
You can pass a local manager multiple locals or add them later by
appending them to <cite>manager.locals</cite>.  Everytime the manager cleans up it,
will clean up all the data left in the locals for this context.</p>
<dl>
<dt><cite id="werkzeug.local.LocalManager.cleanup">cleanup</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Manually clean up the data in the locals for this context.  Call this
at the end of the request or use <cite>make_middleware()</cite>.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.local.LocalManager.make_middleware">make_middleware</cite> <tt class="func-signature docutils literal"><span class="pre">(app)</span></tt></dt>
<dd>Wrap a WSGI application so that cleaning up happens after
request end.</dd>
</dl>
<dl>
<dt><cite id="werkzeug.local.LocalManager.middleware">middleware</cite> <tt class="func-signature docutils literal"><span class="pre">(func)</span></tt></dt>
<dd><p class="first">Like <cite>make_middleware</cite> but for decorating functions.  Example
usage:</p>
<div class="syntax"><pre><span class="nd">@manager</span><span class="o">.</span><span class="n">middleware</span>
<span class="k">def</span> <span class="nf">application</span><span class="p">(</span><span class="n">environ</span><span class="p">,</span> <span class="n">start_response</span><span class="p">):</span>
    <span class="o">...</span>
</pre></div>
<p class="last">The difference to <cite>make_middleware</cite> is that the function passed
will have all the arguments copied from the inner application
(name, docstring, module).</p>
</dd>
</dl>
<dl class="last">
<dt><cite id="werkzeug.local.LocalManager.get_ident">get_ident</cite> <tt class="func-signature docutils literal"><span class="pre">()</span></tt></dt>
<dd>Return the context identifier the local objects use internally for
this context.  You cannot override this method to change the behavior
but use it to link other context local objects (such as SQLAlchemy&#8217;s
scoped sessions) to the Werkzeug locals.</dd>
</dl>
</dd>
</dl>
<dl>
<dt><strong>class</strong> <cite id="werkzeug.local.LocalProxy">LocalProxy</cite></dt>
<dd><p class="first">Acts as a proxy for a werkzeug local.  Forwards all operations to
a proxied object.  The only operations not supported for forwarding
are right handed operands and any kind of assignment.</p>
<p>Example usage:</p>
<div class="syntax"><pre><span class="k">from</span> <span class="nn">werkzeug</span> <span class="k">import</span> <span class="n">Local</span>
<span class="n">l</span> <span class="o">=</span> <span class="n">Local</span><span class="p">()</span>
<span class="n">request</span> <span class="o">=</span> <span class="n">l</span><span class="p">(</span><span class="s">&#39;request&#39;</span><span class="p">)</span>
<span class="n">user</span> <span class="o">=</span> <span class="n">l</span><span class="p">(</span><span class="s">&#39;user&#39;</span><span class="p">)</span>
</pre></div>
<p>Whenever something is bound to l.user / l.request the proxy objects
will forward all operations.  If no object is bound a <cite>RuntimeError</cite>
will be raised.</p>
<p>Keep in mind that <tt class="docutils literal"><span class="pre">repr()</span></tt> is also forwarded, so if you want to find
out if you are dealing with a proxy you can do an <tt class="docutils literal"><span class="pre">isinstance()</span></tt> check:</p>
<div class="syntax"><pre><span class="gp">&gt;&gt;&gt; </span><span class="k">from</span> <span class="nn">werkzeug</span> <span class="k">import</span> <span class="n">LocalProxy</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">isinstance</span><span class="p">(</span><span class="n">request</span><span class="p">,</span> <span class="n">LocalProxy</span><span class="p">)</span>
<span class="go">True</span>
</pre></div>
<p>You can also create proxy objects by hand:</p>
<div class="last"><div class="syntax"><pre><span class="k">from</span> <span class="nn">werkzeug</span> <span class="k">import</span> <span class="n">Local</span><span class="p">,</span> <span class="n">LocalProxy</span>
<span class="n">local</span> <span class="o">=</span> <span class="n">Local</span><span class="p">()</span>
<span class="n">request</span> <span class="o">=</span> <span class="n">LocalProxy</span><span class="p">(</span><span class="n">local</span><span class="p">,</span> <span class="s">&#39;request&#39;</span><span class="p">)</span>
</pre></div>
</div></dd>
</dl>
</div>

      <div style="clear:both"></div>
    </div>
    <div class="footer">
      Werkzeug is a <a href="http://pocoo.org/">Pocoo</a> project licensed under the
      BSD license.
    </div>
  </div>
</body>
</html>